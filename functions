#!/usr/bin/env bash

# vim:fileencoding=utf-8:foldmethod=marker:filetype=bash

# functions for bashrc
#
# author: RilCritch

# Imports - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
. ${BASH_HOME}/ansi_escape_sequences
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# Utilities {{{

## directory tests {{{{

# Check if argument for dir is empty or a valid dir
#  This function defaults to the $HOME dir
# |- Arg 1 is empty: dir -> $HOME
# |- Arg 1 is Dir:   dir -> $1
# |- Arg 1 is ! Dir: dir -> "" (empty string denotes failure)
get-dir-h() {
    if [[ -z "$1" ]]; then
        echo "${HOME}"
    else
        if [[ -d "$1" ]]; then
            echo "${1}"
        else
            echo ""
        fi
    fi
}
 
# Check if argument for dir is empty or a valid dir
#  This function defaults to the working directory
# |- Same as get-dir-c but default is current directory
get-dir-c() {
    if [[ -z "$1" ]]; then
        \pwd
    else
        if [[ -d "$1" ]]; then
            echo "${1}"
        else
            echo ""
        fi
    fi
}
# }}}}

## Size Calculations {{{{

# Returns the recommended size of a tree
# |- When empty string is returned no tree is recommended
# |- Note: this function assumes you've already check for valid dir
tree-size() {
    if [[ -z $2 ]]; then
        extra_lines="0"
    else
        if [[ "$2" =~ ^-?[0-9]+$ ]]; then
            extra_lines="$2"
        else
            extra_lines="0"
        fi
    fi 
    term_height=$(tput lines)
    height=$((term_height - extra_lines))

    if [[ $(\eza -Ta -L=2  "$1" | wc -l) -lt "$height" ]]; then
        echo "2"
    elif [[ $(\eza -Ta -L=1  "$1" | wc -l) -lt "$height" ]]; then
        echo "1"
    else
        echo "0"
    fi
}

# }}}}

# }}}


# Directory Listing {{{

## Recursive {{{{

lsr() {
	local size="$1"

	# Default size of 2
	if [ -z "$size" ] || [ "$size" -le 0 ]; then
		size=2
	fi

	eza -R --icons -L="$size" --group-directories-first
}

clsr() {
	local size="$1"

	# Default size of 2
	if [ -z "$size" ] || [ "$size" -le 0 ]; then
		size=2
	fi

	clear
	eza -R --icons -L="$size" --group-directories-first
}
# }}}}

## Tree {{{{

lst() {
	local size="$1"

	# Default size of 2
	if [ -z "$size" ] || [ "$size" -le 0 ]; then
		size=2
	fi

	eza -T --icons -L="$size" --group-directories-first
}

clst() {
	local size="$1"

	# Default size of 2
	if [ -z "$size" ] || [ "$size" -le 0 ]; then
		size=2
	fi

	clear
	eza -T --icons -L="$size" --group-directories-first
}

clsta() {
	local size="$1"

	# Default size of 2
	if [ -z "$size" ] || [ "$size" -le 0 ]; then
		size=2
	fi

	clear
	eza -Ta --icons -L="$size" --group-directories-first
}
# }}}}

## In depth list outputs {{{{

# Directory overview
# |- Arg 1: Directory to list (must be valid dir, default: pwd)
dir-overview() {
    dir_name=$(get-dir-c "$1")
    if [[ -z "$dir_name" ]]; then
        echo -e "${red}ERROR: ${reset}Specified Directory ${blue}${1} ${reset}does not exist."
        return 2
    fi

    dir_path=$(realpath "${dir_name}")
    num_files=$(fdfind . "${dir_path}" -H --type f --max-depth 1 | wc -l)
    num_dirs=$(fdfind . "${dir_path}" -H --type d --max-depth 1 | wc -l)
    num_links=$(fdfind . "${dir_path}" -H --type l --max-depth 1 | wc -l)
    tree_height=$(tree-size "$dir_path" "4")

    # output
    # across-line | clr blackL

    echo -en "${cyan} "
    echo -en "${bold}${dir_path}${reset} ${l_black}|"

    echo -en "${reset}  "
    echo -en "${dim} ${num_files}${reset} ${l_black}|"

    echo -en "${blue}  "
    echo -en "${dim} ${num_dirs}${reset} ${l_black}|"

    echo -en "${cyan}  "
    echo -e "${dim} ${num_links}"


    if [[ "$tree_height" -eq 0 ]]; then
        across-line | clr blackL
        term_width=$(tput cols)
        col_width=$((term_width - 1))
        # eza -a --group-directories-first --icons=always "$dir_path" | awk '{print " " $0}' | column --output-width ${col_width}
        eza -a --group-directories-first --icons=always "$dir_path"
    else
        dir_length=${#dir_path}
        files_length=${#num_files}
        dirs_length=${#num_dirs}
        links_length=${#num_links}

        linewidth=$((dir_length + files_length + dirs_length + links_length + 19))

        echo -e -n "${l_black}┌"
        for (( i=1 ; i<=linewidth; i++ )); do
            echo -n "─"
        done
        echo
	    # eza -T --icons -L="$tree_height" --group-directories-first | awk '{print "  " $0}' | sed '1d'
	    # eza -T --icons -L="$tree_height" --group-directories-first  | sed '1d'
	    eza -Ta --icons="always" -L="$tree_height" --group-directories-first "$dir_path" | awk 'NR > 1'
    fi
}
# }}}}

# }}}


# FZF cd {{{

# fast cd - verbose and clear screen
d() {
    # Test for specified dir
    dir_name=$(get-dir-h "$1")
    if [[ -z "$dir_name" ]]; then
        echo -e "Specified Directory ${blue}${1}${reset} does not exist."
    fi

    dir_path=$(realpath "${dir_name}")

	choice=$(fdfind . "$dir_path" -H --type d | sed "s|${dir_path}/||" | fzf --border-label=" 󰥨 ${dir_path}/ " --preview "eza --tree -la --icons -F -L=2 --group-directories-first --no-filesize --no-user --no-time --no-permissions {}")

	if [ -n "$choice" ]; then
		cd "${dir_path}/${choice}" || return 2
		clear

        # echo "line 208 dir: ${dir_path}/${choice}"

        dir-overview "${dir_path}/${choice}"
        echo
	fi
}

# fast cd on root - verbose and clear screen
dr() {
	sudo -v
	choice=$(sudo fdfind . / -type d | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview 'eza --tree -la --icons -F -L=2 --group-directories-first --no-filesize --no-user --no-time --no-permissions {}')

	if [ -n "$choice" ]; then
		cd $choice
		clear

		# sparky | clr blackL
        echo -e "${black}-| ${cyan}${bold}$(\pwd)${reset}${black} |-${reset}"
		# eza -la --group-directories-first --icons --grid --no-user --no-filesize
        lsa
		lineacross | clr blackL
	fi
}

# Fast cd to my repos
r() {
	choice=$(\ls /home/rc/Repos/ | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview 'eza --tree -la --icons -F -L=2 --group-directories-first --no-filesize --no-user --no-time --no-permissions {}')

    if [ -n "$choice" ]; then
        cd "/home/rc/Repos/${choice}"
        clear

        sparky | clr blackL
        repo-header

        echo

        lsa
    fi
}

# Fast cd through notes
n() {
	choice=$( fdfind . "$HOME/Repos/notes-ril" --type d | sed 's|/home/rc/Repos/notes-ril/||' | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview "eza --tree -la --icons -F -L=2 --group-directories-first --no-filesize --no-user --no-permissions --no-time ${HOME}/Repos/notes-ril/{}")

    if [ -n "$choice" ]; then
        cd "${HOME}/Repos/notes-ril/${choice}"
        clear

        clst
    fi
}
# }}}


# FZF packages {{{

# debian packages
ddf() {
	choice=$(apt-cache -n search '.*' | awk -F ' - ' '{print $1}' | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview 'nala show {}')

	if [ -n "$choice" ]; then
		echo "Installing $choice" | clr cyan
	    sudo nala install $choice	
	fi

}

# pacman searching
pacf() {
	choice=$(pacman -Slq | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview 'pacman -Si {}')

	if [ -n "$choice" ]; then
		echo "Installing $choice" | clr green
		sudo pacman -S $choice
	fi
}

# AUR searching
aurf() {
	choice=$(paru -a -Slq | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview 'paru -Si {}')

	if [ -n "$choice" ]; then
		echo "Installing $choice" | clr green
		paru $choice
	fi
}

flatf() {
	choice=$(flatpak remote-ls flathub | awk '{ printf "%s %s\n", $1, $2, $3 }' | fzf --header-first --reverse --prompt='▶ ' --pointer='󱦰' --preview $'flatpak remote-info flathub "$(echo {} | awk \'{printf "%s", $2}\')"')

	if [ -n "$choice" ]; then
		echo "Installing $choice" | clr green
		flatpak install flathub $choice
	fi
}
# }}}


# FZF neovim {{{

snv() {
	# items=("default" "from-scratch" "lazy-nvim" "nv-chad" )
    items=$(\ls ~/.config/neovim/)
	config=$(printf "%s\n" "${items[@]}" | fzf --prompt=" Neovim Config   " --exit-0)
	if [[ -z $config ]]; then
		# echo "Nothing selected"
		return 0
    else
        config="neovim/${config}"
	fi
	NVIM_APPNAME=$config nvim $@
}
# }}}


# Navigation {{{

# Moving up directories
up() {
	local d=""
	local limit="$1"

	# Default to limit of 1
	if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
		limit=1
	fi

	for ((i = 1; i <= limit; i++)); do
		d="../$d"
	done

	# perform cd. Show error if cd fails
	if ! cd "$d"; then
		echo "Couldn't go up $limit dirs."
	fi
}
# }}}


# EXtractor for all kinds of archives {{{
# usage: ex <file>
ex() {
	if [ -f $1 ]; then
		case $1 in
		*.tar.bz2) tar xf $1 ;;
		*.tar.gz) tar xzf $1 ;;
		*.bz2) bunzip2 $1 ;;
		*.rar) unrar x $1 ;;
		*.gz) gunzip $1 ;;
		*.tar) tar xf $1 ;;
		*.tbz2) tar xf $1 ;;
		*.tgz) tar xzf $1 ;;
		*.zip) unzip $1 ;;
		*.Z) uncompress $1 ;;
		*.7z) 7z x $1 ;;
		*.deb) ar x $1 ;;
		*.tar.xz) tar xf $1 ;;
		*.tar.zst) tar xf $1 ;;
		*) echo "'$1' cannot be extracted via ex()" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}
# }}}


# show the list of packages that need this package - depends mpv as example {{{
depends() {
	search=$(echo "$1")
	sudo pacman -Sii $search | grep "Required" | sed -e "s/Required By     : //g" | sed -e "s/  /\n/g"
}
# }}}


# get a color palette for an image {{{
palette() {
	img=$1

	vimg $img

	# hex values
	~/mydots/applications/okolors -k 10 -w 0.01 -n 3 -l 10,30,50,70 -s l $img

	# swatch
	~/mydots/applications/okolors -k 10 -w 0.01 -n 3 -l 10,30,50,70 -s l -o swatch $img
}
# }}}


# vim: ts=4 sts=4 sw=4 et
